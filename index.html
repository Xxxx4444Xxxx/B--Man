<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>BÃ¶-Man</title>
  <style>
    html, body { height: 100%; margin: 0; background: #05040a; color:#f1eaff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #wrap { position: fixed; inset: 0; display: grid; grid-template-rows: auto 1fr; }
    #hud { padding: 8px 10px; display: flex; justify-content: space-between; align-items: center; font-family: monospace; text-shadow: 0 0 6px #9a6bff; z-index: 3; }
    #canvas { width: 100%; height: 100%; display: block; box-shadow: inset 0 0 48px rgba(138,92,255,.35); image-rendering: pixelated; background: #000; }
    .crt::after { content:''; position:fixed; inset:0; pointer-events:none; background: repeating-linear-gradient(0deg, rgba(255,255,255,0.04) 0, rgba(255,255,255,0.04) 1px, rgba(0,0,0,0) 2px); mix-blend-mode: overlay; z-index:2; }
    #btnMute { position: fixed; right: 14px; bottom: 14px; background: rgba(20,16,40,.85); border: 1px solid #9a6bff; color: #f1eaff; padding: 8px 12px; border-radius: 8px; font-family: monospace; z-index: 4; }

    /* Dâ€‘Pad */
    .dpad { position: fixed; left: 14px; bottom: 14px; width: 180px; height: 180px; z-index: 4; }
    .dpad button {
      position: absolute; width: 64px; height: 64px; border-radius: 12px;
      background: rgba(20,16,40,.85); border: 1px solid #9a6bff;
      color:#f1eaff; font-size: 22px; font-weight: 700;
      touch-action: none;
    }
    .dpad .up    { left: 58px; top: 0; }
    .dpad .down  { left: 58px; bottom: 0; }
    .dpad .left  { left: 0; top: 58px; }
    .dpad .right { right: 0; top: 58px; }
  </style>
</head>
<body class="crt">
  <div id="wrap">
    <div id="hud"><div id="score">BÃ¶-Man Â· Score: 0 Â· Lives: 3</div><div id="status">Ready!</div></div>
    <canvas id="canvas" width="608" height="736"></canvas>
  </div>
  <div class="dpad" id="dpad">
    <button class="up">â–²</button>
    <button class="down">â–¼</button>
    <button class="left">â—€</button>
    <button class="right">â–¶</button>
  </div>
  <button id="btnMute">ðŸ”Š</button>

<script>
// ===== Vanilla BÃ¶-Man (keine externen Bibliotheken) =====
// WÃ¼nsche umgesetzt:
// - GrÃ¶ÃŸerer MaÃŸstab (Figur, Wege, Blumen)
// - Mehr Blumen (wie Pac-Man): alle freien Felder gefÃ¼llt, auÃŸer Start/Gegnerzellen
// - Gegner sind Fliegen; werden blau, wenn "Super-Knospe" aktiv
// - Beim Essen erscheint aufsteigendes "BÃ¶"
// - Dâ€‘Pad Steuerung (Buttons), Keyboard bleibt

const TILE = 32;                       // grÃ¶ÃŸerer MaÃŸstab
const COLS = 19, ROWS = 23;
const W = COLS*TILE, H = ROWS*TILE;
const SPEED_PLAYER = 2.2;              // gefÃ¼hlt etwas flotter auf grÃ¶ÃŸerer Skala
const SPEED_ENEMY  = 1.8;
const DUR = { super: 10000, slow: 6000, magnet: 8000 };

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = W; canvas.height = H;

const scoreEl = document.getElementById('score');
const statusEl = document.getElementById('status');
const btnMute = document.getElementById('btnMute');

// Maze-Vorlage (1=Wand, 0=leer, 3=Powerup-Spot)
const MAZE_STR = [
  '1111111111111111111',
  '1000000003000000001',
  '1011110111110111101',
  '1030010303030300031',
  '1011011110111110111',
  '1001010000100001011',
  '1111010111101111011',
  '1003030100030103031',
  '1011110111100111101',
  '1000030003000300031',
  '1111011110111110111',
  '1001010000100001001',
  '1030010303030300031',
  '1011110111110111101',
  '1000000100000100001',
  '1111110111101111111',
  '1000030003000300001',
  '1011110111110111101',
  '1000000100000100001',
  '1011110111101111101',
  '1000000003000000001',
  '1011111110111111101',
  '1111111111111111111',
];
const MAZE = MAZE_STR.map(r => r.split('').map(ch => +ch));

// Sets/Maps
let walls = new Set();
let plants = new Set();
let powerups = new Map(); // key "c,r" -> 'super'|'slow'|'magnet'
let effects = [];         // floating "BÃ¶" texts

function K(c,r){ return c+','+r; }
function inBounds(c,r){ return c>=0 && c<COLS && r>=0 && r<ROWS; }

// Init: FÃ¼lle alle nicht-Wand Felder mit Blumen (auÃŸer Startbereiche)
for (let r=0;r<ROWS;r++){
  for (let c=0;c<COLS;c++){
    if (MAZE[r][c]===1) { walls.add(K(c,r)); continue; }
    if (MAZE[r][c]===3) {
      const kinds = ['super','slow','magnet'];
      powerups.set(K(c,r), kinds[Math.floor(Math.random()*kinds.length)]);
      continue;
    }
    // Platzhalter, Pflanzen werden nach Startposition gesetzt
    plants.add(K(c,r));
  }
}

function isWall(c,r){ return walls.has(K(c,r)); }

function spawnFree(){
  for (let r=ROWS-2;r>=1;r--){
    for (let c=1;c<COLS-1;c++){
      if (!isWall(c,r)) return {x:c+0.5, y:r+0.5};
    }
  }
  return {x:1.5,y:1.5};
}

const player = { ...spawnFree(), vx:0, vy:0, dir:'left', super:0, slow:0, magnet:0 };
const enemies = [
  {x:9.5, y:11.5, dir:'left'},
  {x:9.5, y:9.5,  dir:'up'},
  {x:9.5, y:13.5, dir:'down'},
];

// Starte: Entferne Pflanzen direkt auf Startfeldern (Spieler/ Gegner)
function removeAt(c,r){ plants.delete(K(c,r)); powerups.delete(K(c,r)); }
removeAt(Math.floor(player.x), Math.floor(player.y));
enemies.forEach(e => removeAt(Math.floor(e.x), Math.floor(e.y)));

// Punkte/Leben
let score = 0, lives = 3, running = true, muted = false;

// Input: Keyboard
const keys = {ArrowLeft:0,ArrowRight:0,ArrowUp:0,ArrowDown:0};
addEventListener('keydown', e=>{ if(e.key in keys){ keys[e.key]=1; e.preventDefault(); } });
addEventListener('keyup',   e=>{ if(e.key in keys){ keys[e.key]=0; e.preventDefault(); } });

// Input: Dâ€‘Pad
const dpad = document.getElementById('dpad');
function bindBtn(sel, dir){
  const btn = dpad.querySelector(sel);
  const down = (e)=>{ e.preventDefault(); setDir(dir); };
  const up   = (e)=>{ e.preventDefault(); /* keep moving in last dir */ };
  btn.addEventListener('pointerdown', down);
  btn.addEventListener('pointerup', up);
  btn.addEventListener('pointerleave', up);
}
bindBtn('.up','up'); bindBtn('.down','down'); bindBtn('.left','left'); bindBtn('.right','right');
function setDir(d){ keys.ArrowLeft=keys.ArrowRight=keys.ArrowUp=keys.ArrowDown=0;
  if (d==='left') keys.ArrowLeft=1;
  if (d==='right') keys.ArrowRight=1;
  if (d==='up') keys.ArrowUp=1;
  if (d==='down') keys.ArrowDown=1;
}

// Audio (Beep)
const AC = new (window.AudioContext||window.webkitAudioContext)();
function beep(freq, dur=0.08, vol=0.15){
  if (muted) return;
  const o = AC.createOscillator();
  const g = AC.createGain();
  o.type='square'; o.frequency.value=freq;
  g.gain.value=vol;
  o.connect(g); g.connect(AC.destination);
  o.start();
  setTimeout(()=>{ o.stop(); }, dur*1000);
}
document.getElementById('btnMute').addEventListener('click', ()=>{ muted=!muted; btnMute.textContent = muted?'ðŸ”‡':'ðŸ”Š'; });

function gridBlocked(nx, ny){
  const c = Math.floor(nx), r = Math.floor(ny);
  return isWall(c, r);
}

// "BÃ¶" Effekt an Spielerposition
function spawnBo(){
  effects.push({ x: player.x*TILE, y: player.y*TILE-6, t: 700, txt: 'BÃ¶' });
}

function step(dt){
  // timers
  player.super = Math.max(0, player.super - dt);
  player.slow  = Math.max(0, player.slow  - dt);
  player.magnet= Math.max(0, player.magnet- dt);

  // input â†’ dir
  let dir=null;
  if (keys.ArrowLeft) dir='left';
  else if (keys.ArrowRight) dir='right';
  else if (keys.ArrowUp) dir='up';
  else if (keys.ArrowDown) dir='down';

  // move player
  const sp = SPEED_PLAYER;
  let vx=0, vy=0;
  if (dir==='left')  vx=-sp;
  if (dir==='right') vx= sp;
  if (dir==='up')    vy=-sp;
  if (dir==='down')  vy= sp;

  const nx = player.x + vx*dt/16/ TILE;
  const ny = player.y + vy*dt/16/ TILE;
  if (!gridBlocked(nx, player.y)) player.x = nx;
  if (!gridBlocked(player.x, ny)) player.y = ny;

  // eat plants
  const pc = Math.floor(player.x), pr = Math.floor(player.y);
  const pkey = K(pc,pr);
  if (plants.has(pkey)){
    plants.delete(pkey);
    score += 10; scoreEl.textContent = `BÃ¶-Man Â· Score: ${score} Â· Lives: ${lives}`;
    spawnBo();
    beep(520,0.05,0.12);
    if (plants.size===0){ statusEl.textContent='Level geschafft!'; beep(880,0.2,0.2); }
  }
  // powerups
  if (powerups.has(pkey)){
    const kind = powerups.get(pkey);
    powerups.delete(pkey);
    if (kind==='super'){ player.super = DUR.super; statusEl.textContent='Super-Knospe!'; }
    if (kind==='slow'){  player.slow  = DUR.slow;  statusEl.textContent='Zeitlupe!'; }
    if (kind==='magnet'){player.magnet= DUR.magnet;statusEl.textContent='Magnet!'; }
  }

  // magnet pull (grÃ¶ÃŸerer Radius bei grÃ¶ÃŸerer Skala)
  if (player.magnet>0){
    const range = 3.0;
    for (const k of [...plants]){
      const [c,r] = k.split(',').map(Number);
      const dx = (c+0.5) - player.x, dy = (r+0.5) - player.y;
      const d = Math.hypot(dx,dy);
      if (d < range && d>0.01){
        const nx = (c+0.5) - dx/d*0.05;
        const ny = (r+0.5) - dy/d*0.05;
        if (Math.hypot(nx-(c+0.5), ny-(r+0.5))>0.3){
          plants.delete(k);
          score += 10; scoreEl.textContent = `BÃ¶-Man Â· Score: ${score} Â· Lives: ${lives}`;
          spawnBo();
          beep(520,0.05,0.12);
        }
      }
    }
  }

  // enemies movement
  enemies.forEach(e=>{
    const s = (player.slow>0 ? 0.45 : 1) * SPEED_ENEMY;
    if (!e.dir || willHitWall(e, e.dir, s, dt)){
      const opts = dirsAt(e.x, e.y);
      if (opts.length){
        const opp = opposite(e.dir);
        const cand = opts.length>1 ? opts.filter(d=>d!==opp) : opts;
        e.dir = cand[Math.floor(Math.random()*cand.length)];
      }
    }
    let vx=0, vy=0;
    if (e.dir==='left') vx=-s;
    if (e.dir==='right') vx=s;
    if (e.dir==='up') vy=-s;
    if (e.dir==='down') vy=s;
    const nx = e.x + vx*dt/16/ TILE;
    const ny = e.y + vy*dt/16/ TILE;
    if (!gridBlocked(nx, e.y)) e.x = nx;
    if (!gridBlocked(e.x, ny)) e.y = ny;
  });

  // collisions with enemies
  enemies.forEach(e=>{
    const d = Math.hypot(e.x - player.x, e.y - player.y);
    if (d < 0.65){
      if (player.super>0){
        // eat enemy: respawn
        e.x = 9.5; e.y = 11.5; e.dir = null;
        score += 200; scoreEl.textContent = `BÃ¶-Man Â· Score: ${score} Â· Lives: ${lives}`;
        beep(560,0.06,0.2);
      } else {
        lives -= 1; scoreEl.textContent = `BÃ¶-Man Â· Score: ${score} Â· Lives: ${lives}`;
        statusEl.textContent = lives>0 ? 'Autsch! Weiterâ€¦' : 'Game Over';
        beep(140,0.3,0.25);
        if (lives<=0){ running=false; }
        else { const p = spawnFree(); player.x=p.x; player.y=p.y; }
      }
    }
  });

  // update effects
  effects = effects.map(e => ({...e, y: e.y-0.05*TILE, t: e.t-dt})).filter(e => e.t>0);
}

function willHitWall(ent, dir, s, dt){
  let vx=0,vy=0;
  if (dir==='left') vx=-s;
  if (dir==='right') vx=s;
  if (dir==='up') vy=-s;
  if (dir==='down') vy=s;
  const nx = ent.x + vx*dt/16/ TILE;
  const ny = ent.y + vy*dt/16/ TILE;
  return gridBlocked(nx, ent.y) || gridBlocked(ent.x, ny);
}
function dirsAt(x,y){
  const c=Math.floor(x), r=Math.floor(y), o=[];
  if (inBounds(c-1,r) && !isWall(c-1,r)) o.push('left');
  if (inBounds(c+1,r) && !isWall(c+1,r)) o.push('right');
  if (inBounds(c,r-1) && !isWall(c,r-1)) o.push('up');
  if (inBounds(c,r+1) && !isWall(c,r+1)) o.push('down');
  return o;
}
function opposite(d){ return d==='left'?'right':d==='right'?'left':d==='up'?'down':d==='down'?'up':null; }

// ---- Render ----
function drawWalls(){
  for (let r=0;r<ROWS;r++){
    for (let c=0;c<COLS;c++){
      if (MAZE[r][c]===1){
        // Dickere WÃ¤nde, grÃ¶ÃŸere Wege
        ctx.fillStyle = '#25253a';
        ctx.fillRect(c*TILE, r*TILE, TILE, TILE);
        ctx.strokeStyle = '#161621';
        ctx.lineWidth = 2;
        ctx.strokeRect(c*TILE+1, r*TILE+1, TILE-2, TILE-2);
      }
    }
  }
}

function drawFlower(cx, cy){
  // GroÃŸe Blumen: Stiel + 6 BlÃ¼tenblÃ¤tter + gelbe Mitte
  const x = cx*TILE + TILE/2, y = cy*TILE + TILE/2;
  const s = Math.max(3, Math.floor(TILE*0.12));
  // Stiel
  ctx.strokeStyle = '#46b446'; ctx.lineWidth = Math.max(2, Math.floor(TILE*0.07));
  ctx.beginPath(); ctx.moveTo(x, y+s*2); ctx.lineTo(x, y+s*4); ctx.stroke();
  // BlÃ¤tter
  const petalR = Math.max(4, Math.floor(TILE*0.18));
  ctx.fillStyle = '#ff7ad9';
  for (let i=0;i<6;i++){
    const a = i*Math.PI/3;
    ctx.beginPath();
    ctx.ellipse(x + Math.cos(a)*petalR, y + Math.sin(a)*petalR, petalR*0.6, petalR*0.9, a, 0, Math.PI*2);
    ctx.fill();
  }
  // Mitte
  ctx.fillStyle = '#ffd25a';
  ctx.beginPath(); ctx.arc(x, y, petalR*0.6, 0, Math.PI*2); ctx.fill();
}

function drawPowerup(cx, cy, kind){
  const x = cx*TILE + TILE/2, y = cy*TILE + TILE/2;
  ctx.fillStyle = kind==='super' ? '#ff7ad9' : kind==='slow' ? '#ffd25a' : '#7aa8ff';
  ctx.beginPath(); ctx.arc(x, y, Math.floor(TILE*0.22), 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = '#ffffff55'; ctx.lineWidth = 2; ctx.stroke();
}

function drawFly(e){
  const x=e.x*TILE, y=e.y*TILE;
  const bodyR = Math.floor(TILE*0.33);
  // KÃ¶rper
  ctx.fillStyle = (player.super>0) ? '#5ac8ff' : '#2c2c38';
  ctx.beginPath(); ctx.ellipse(x, y, bodyR, bodyR*0.8, 0, 0, Math.PI*2); ctx.fill();
  // Kopf
  ctx.fillStyle = (player.super>0) ? '#5ac8ff' : '#3a3a4e';
  ctx.beginPath(); ctx.arc(x+bodyR*0.8, y-2, bodyR*0.45, 0, Math.PI*2); ctx.fill();
  // Augen
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(x+bodyR*0.95, y-4, 3, 0, Math.PI*2); ctx.fill();
  // FlÃ¼gel
  ctx.fillStyle = 'rgba(180,200,255,0.5)';
  ctx.beginPath(); ctx.ellipse(x-bodyR*0.4, y-bodyR*0.8, bodyR*0.7, bodyR*0.4, -0.6, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(x-bodyR*0.1, y-bodyR*0.85, bodyR*0.7, bodyR*0.4, -0.3, 0, Math.PI*2); ctx.fill();
}

function drawPlayer(){
  const px = player.x*TILE, py=player.y*TILE;
  const R = Math.floor(TILE*0.42); // grÃ¶ÃŸer als Gegner
  // Outline
  ctx.lineWidth=4; ctx.strokeStyle='#000';
  ctx.beginPath(); ctx.arc(px, py, R+2, 0, Math.PI*2); ctx.stroke();
  // Body
  ctx.fillStyle='#b36bff';
  ctx.beginPath(); ctx.arc(px, py, R, 0, Math.PI*2); ctx.fill();
  // Mouth (animated)
  const open = (Date.now()>>7)%2===0 ? 0.55 : 0.25;
  let angStart = -open, angEnd = open;
  if (keys.ArrowLeft){ angStart = Math.PI - open; angEnd = -Math.PI + open; }
  if (keys.ArrowRight){ angStart = -open; angEnd = open; }
  if (keys.ArrowUp){ angStart = -Math.PI/2 - open; angEnd = -Math.PI/2 + open; }
  if (keys.ArrowDown){ angStart = Math.PI/2 - open; angEnd = Math.PI/2 + open; }
  ctx.fillStyle = '#05040a';
  ctx.beginPath(); ctx.moveTo(px,py); ctx.arc(px,py,R,angStart,angEnd,false); ctx.closePath(); ctx.fill();
  // Eyes
  ctx.fillStyle='#fff';
  ctx.beginPath(); ctx.arc(px-6, py-7, 3, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(px+6, py-7, 3, 0, Math.PI*2); ctx.fill();
}

function drawEffects(){
  ctx.font = `${Math.floor(TILE*0.6)}px monospace`;
  ctx.textAlign='center'; ctx.textBaseline='middle';
  effects.forEach(e=>{
    ctx.fillStyle = `rgba(241,234,255,${Math.max(0, e.t/700)})`;
    ctx.fillText(e.txt, e.x, e.y);
  });
}

function draw(){
  ctx.clearRect(0,0,W,H);
  drawWalls();

  // Blumen
  plants.forEach(k=>{
    const [c,r] = k.split(',').map(Number);
    drawFlower(c,r);
  });

  // Powerups
  powerups.forEach((kind,k)=>{
    const [c,r] = k.split(',').map(Number);
    drawPowerup(c,r,kind);
  });

  // Gegner (Fliegen)
  enemies.forEach(drawFly);

  // Spieler
  drawPlayer();

  // Effekte ("BÃ¶")
  drawEffects();
}

function loop(now){
  const dt = 16; // fixe Schritte fÃ¼r Einfachheit
  if (running) step(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
